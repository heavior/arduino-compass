<!DOCTYPE html>
<html>
  <body>
    <button id="connect">Connect to Arduino</button>

    <input type="text" id="numberInput" placeholder="Enter angle">
    <button id="sendButton" disabled>Start calibration</button>

    <button id="downloadRaw" style="display: none;">Download raw CSV</button>
    <button id="downloadCalibration" style="display: none;">Download calibration CSV</button>
    <div id="status">Status: Disconnected</div>
    <div id="counter">Row count: 0</div>
    <div id="output">Latest Values: N/A</div>
    <table id="calibrationTable" style="width:100%; text-align:center;">
      <tr>
        <th>Angle</th>
        <th>Bias X</th>
        <th>Bias Y</th>
        <th>Bias Z</th>
        <th>Scale 1</th>
        <th>Scale 2</th>
        <th>Scale 3</th>
        <th>Scale 4</th>
        <th>Scale 5</th>
        <th>Scale 6</th>
        <th>Scale 7</th>
        <th>Scale 8</th>
        <th>Scale 9</th>
        <th>condition</th>
      </tr>
    </table>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/10.4.0/math.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/numeric/1.2.6/numeric.min.js"></script>
    
    <script>
      let characteristicCalibrationReader;
      let characteristicCalibrationStarter;
      let readings = [];
      let device;


      let lsqminnorm = function(A, b) {
        const AtA = math.multiply(math.transpose(A), A);
        const Atb = math.multiply(math.transpose(A), b);
        const x = math.multiply(math.inv(AtA), Atb);
        return x;
      }
      function conditionNumber(data) {
        // Select the first three columns of the data
        const selectedData = data.map(row => row.slice(0, 3));

        // Calculate SVD
        const svd = numeric.svd(selectedData);

        // Get the maximum singular value
        const maxSingularValue = Math.max(...svd.S);

        // Get the minimum singular value
        const minSingularValue = Math.min(...svd.S);

        // Calculate and return the condition number
        return maxSingularValue / minSingularValue;
      }

      let ellipsoidFit = (data) => {
        const n = data.length;

        const x = data.map(pt => pt[0]);
        const y = data.map(pt => pt[1]);
        const z = data.map(pt => pt[2]);
        
        
        const D = math.transpose([
            x.map((xi, i) => xi * xi + y[i] * y[i] - 2 * z[i] * z[i]),
            x.map((xi, i) => xi * xi + z[i] * z[i] - 2 * y[i] * y[i]),
            x.map((xi, i) => 2 * xi * y[i]),
            x.map((xi, i) => 2 * xi * z[i]),
            y.map((yi, i) => 2 * yi * z[i]),
            x.map(xi => 2 * xi),
            y.map(yi => 2 * yi),
            z.map(zi => 2 * zi),
            Array(n).fill(1)
        ]);


        const d2 = x.map((xi, idx) => xi*xi + y[idx]*y[idx] + z[idx]*z[idx]);

        const u = lsqminnorm(D, d2);

        const a = u[0] + 1;
        const b = u[1] + 1;
        const c = 1;

        const v = [u[2], u[3], u[4], -u[5], -u[6], -u[7], u[8]];
        
        const A = [[a, v[0], v[3]], [v[0], b, v[4]], [v[3], v[4], c]];

        const center = math.multiply(-1, math.multiply(math.inv(A), v.slice(4, 7)));

        return [A, center];
      };

      const calibrateMagnetometer = (data) => {
        const [A, center] = ellipsoidFit(data);
        const invA = math.inv(A);

        const scale = math.sqrt(invA);
        const bias = math.multiply(scale, center);

        return [scale, bias];
      };
      const SERVICE_UUID = '66c41382-675a-4ec8-af51-82456e148c79';

      const BLUETOOTH_CALIBRATE_CHARACTERISTIC_UUID = "8a257ab3-65e9-4647-98ab-d07fc9bc78b0";
      const BLUETOOTH_CALIBRATE_CONTROL_CHARACTERISTIC_UUID = "3c9d3165-a6ef-42c6-9956-01827683c3d6";

      let connect = async () => {
        try {
          // Request Bluetooth device
          const device = await navigator.bluetooth.requestDevice({
            filters: [{ services: [SERVICE_UUID] }]
          });

          // Connect to the device
          const server = await device.gatt.connect();

          // Get the service
          const service = await server.getPrimaryService(SERVICE_UUID);

          // Get the characteristic
          
          characteristicCalibrationStarter = await service.getCharacteristic(BLUETOOTH_CALIBRATE_CONTROL_CHARACTERISTIC_UUID);
          

          characteristicCalibrationReader = await service.getCharacteristic(BLUETOOTH_CALIBRATE_CHARACTERISTIC_UUID);
          characteristicCalibrationReader.startNotifications().then(_ => {
            characteristicCalibrationReader.addEventListener('characteristicvaluechanged', handleData);});

          sendButton.disabled = false;
          console.log('Connected to the device.');

          document.querySelector('#status').innerText = "Status: Connected";
        } catch (error) {
          console.error('Error:', error);

          document.querySelector('#status').innerText = "Status: Disconnected";
        }
      }
      document.querySelector('#connect').addEventListener('click', async () =>{
        if(!device){
          connect();
        }
      });


      sendButton.addEventListener('click', async () => {
        const number = parseInt(numberInput.value);
        if (!isNaN(number)) {
          try {
            // Encode the command with the number
            const command = new Uint8Array([number]);

            // Write the command
            await characteristicCalibrationStarter.writeValue(command);

            console.log('Command sent successfully.');
          } catch (error) {
            console.error('Error:', error);
          }
        }
      });
      

      let calibrateAll = function(){

        const dataByAngle = {};
          readings.forEach((reading) => {
            if (!dataByAngle[reading[3]]) {
              dataByAngle[reading[3]] = [];
            }
            dataByAngle[reading[3]].push(reading.slice(0, 3));
          });

          // Sorting by angle
          const sortedAngles = Object.keys(dataByAngle).sort((a, b) => a - b);

          const table = document.getElementById('calibrationTable');
          sortedAngles.forEach(angle => {
            const data = dataByAngle[angle];
            const [scale, bias] = calibrateMagnetometer(data);
            const condition = conditionNumber(data);
            console.log(bias);
            let bx = (math.typeOf(bias[0])=='Complex')?'complex':bias[0].toFixed(6);
            let by = (math.typeOf(bias[1])=='Complex')?'complex':bias[1].toFixed(6);
            let bz = (math.typeOf(bias[2])=='Complex')?'complex':bias[2].toFixed(6);

            let row = `<tr><td>${angle}</td><td>${bx}</td><td>${by}</td><td>${bz}</td>`;
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    let value = (math.typeOf(scale[i][j])=='Complex')?'complex':scale[i][j].toFixed(6);
                    row += `<td>${value}</td>`;
                }
            }

            row += `<td>${condition.toFixed(1)}</td>`;
            row += '</tr>';
            table.innerHTML += row;
          });
      }
      function handleData(event) {


        let value = event.target.value;
        let x = value.getFloat32(0, true);
        let y = value.getFloat32(4, true);
        let z = value.getFloat32(8, true);
        let angle = value.getInt32(12, true);
        
        if (angle > -1) {
            readings.push([x, y, z, angle]);

            document.querySelector('#counter').innerText = "Row count: " + readings.length;
            document.querySelector('#output').innerText = `Latest Values: X: ${x}, Y: ${y}, Z: ${z}, Angle: ${angle}`;
        }
        
        if (angle === -1) {
          // Stop notifications code...

          /*characteristicCalibrationReader.stopNotifications().then(_ => {
            if (device.gatt.connected) {
              console.log('Disconnecting from GATT Server...');
              device.gatt.disconnect();
              document.querySelector('#status').innerText = "Status: Disconnected";
            }});*/
          calibrateAll();

          document.querySelector('#downloadCalibration').style.display = 'block';
        }
      }

      document.querySelector('#downloadRaw').addEventListener('click', function() {
        let csvContent = "data:text/csv;charset=utf-8," 
                       + readings.map(e => e.join(",")).join("\n");
        
        let encodedUri = encodeURI(csvContent);
        let link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "readings.csv");
        document.body.appendChild(link); 
        link.click();
      });

      document.querySelector('#downloadCalibration').addEventListener('click', function() {
        let csv = [];
        let rows = document.querySelectorAll("table tr");
        
        for (let i = 0; i < rows.length; i++) {
            let row = [], cols = rows[i].querySelectorAll("td, th");
            
            for (let j = 0; j < cols.length; j++) 
                row.push(cols[j].innerText);
            
            csv.push(row.join(","));        
        }

        downloadCSV(csv.join("\n"), "calibration_data.csv");
      });

      function downloadCSV(csv, filename) {
        let csvFile;
        let downloadLink;

        // CSV file
        csvFile = new Blob([csv], {type: "text/csv"});

        // Download link
        downloadLink = document.createElement("a");

        // File name
        downloadLink.download = filename;

        // Create a link to the file
        downloadLink.href = window.URL.createObjectURL(csvFile);

        // Hide download link
        downloadLink.style.display = "none";

        // Add the link to DOM
        document.body.appendChild(downloadLink);

        // Click download link
        downloadLink.click();
      }

    </script>
  </body>
</html>
